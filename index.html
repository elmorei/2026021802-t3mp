<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Flags! - GitHub Pages</title>
    <style>
      :root {
        color-scheme: dark;
      }

      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        background: #05070d;
      }

      #noise {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        image-rendering: pixelated;
      }

      #flags {
        position: fixed;
        left: 0;
        top: 0;
        margin: 0;
        padding: 0.2em 0.4em;
        font-size: clamp(2rem, 10vw, 6rem);
        line-height: 1;
        font-weight: 900;
        color: hsl(0deg 95% 62%);
        text-shadow: 0 0 8px rgb(0 0 0 / 45%), 0 0 20px rgb(255 255 255 / 30%);
        user-select: none;
        cursor: pointer;
        white-space: nowrap;
        will-change: transform;
      }
    </style>
  </head>
  <body>
    <canvas id="noise" aria-hidden="true"></canvas>
    <h1 id="flags">Flags!</h1>

    <script>
      const canvas = document.getElementById('noise');
      const ctx = canvas.getContext('2d', { alpha: false });
      const flags = document.getElementById('flags');

      const state = {
        x: 0,
        y: 0,
        vx: 210,
        vy: 165,
        hue: 0,
        t: 0,
      };

      const noiseBuffer = document.createElement('canvas');
      const noiseCtx = noiseBuffer.getContext('2d', { alpha: false });
      let noiseImageData = null;
      let noiseData = null;
      let noiseWidth = 0;
      let noiseHeight = 0;

      // 4D simplex noise implementation based on Stefan Gustavson's public domain algorithm.
      const grad4 = [
        [0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1],
        [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1],
        [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1],
        [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1],
        [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1],
        [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1],
        [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0],
        [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0],
      ];

      const p = new Uint8Array(256);
      for (let i = 0; i < 256; i++) p[i] = i;
      for (let i = 255; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = p[i];
        p[i] = p[j];
        p[j] = tmp;
      }
      const perm = new Uint8Array(512);
      for (let i = 0; i < 512; i++) perm[i] = p[i & 255];

      const F4 = (Math.sqrt(5) - 1) / 4;
      const G4 = (5 - Math.sqrt(5)) / 20;

      function dot(g, x, y, z, w) {
        return g[0] * x + g[1] * y + g[2] * z + g[3] * w;
      }

      function simplex4D(x, y, z, w) {
        const s = (x + y + z + w) * F4;
        const i = Math.floor(x + s);
        const j = Math.floor(y + s);
        const k = Math.floor(z + s);
        const l = Math.floor(w + s);

        const t = (i + j + k + l) * G4;
        const X0 = i - t;
        const Y0 = j - t;
        const Z0 = k - t;
        const W0 = l - t;

        const x0 = x - X0;
        const y0 = y - Y0;
        const z0 = z - Z0;
        const w0 = w - W0;

        let rankx = 0;
        let ranky = 0;
        let rankz = 0;
        let rankw = 0;

        if (x0 > y0) rankx++; else ranky++;
        if (x0 > z0) rankx++; else rankz++;
        if (x0 > w0) rankx++; else rankw++;
        if (y0 > z0) ranky++; else rankz++;
        if (y0 > w0) ranky++; else rankw++;
        if (z0 > w0) rankz++; else rankw++;

        const i1 = rankx >= 3 ? 1 : 0;
        const j1 = ranky >= 3 ? 1 : 0;
        const k1 = rankz >= 3 ? 1 : 0;
        const l1 = rankw >= 3 ? 1 : 0;

        const i2 = rankx >= 2 ? 1 : 0;
        const j2 = ranky >= 2 ? 1 : 0;
        const k2 = rankz >= 2 ? 1 : 0;
        const l2 = rankw >= 2 ? 1 : 0;

        const i3 = rankx >= 1 ? 1 : 0;
        const j3 = ranky >= 1 ? 1 : 0;
        const k3 = rankz >= 1 ? 1 : 0;
        const l3 = rankw >= 1 ? 1 : 0;

        const x1 = x0 - i1 + G4;
        const y1 = y0 - j1 + G4;
        const z1 = z0 - k1 + G4;
        const w1 = w0 - l1 + G4;

        const x2 = x0 - i2 + 2 * G4;
        const y2 = y0 - j2 + 2 * G4;
        const z2 = z0 - k2 + 2 * G4;
        const w2 = w0 - l2 + 2 * G4;

        const x3 = x0 - i3 + 3 * G4;
        const y3 = y0 - j3 + 3 * G4;
        const z3 = z0 - k3 + 3 * G4;
        const w3 = w0 - l3 + 3 * G4;

        const x4 = x0 - 1 + 4 * G4;
        const y4 = y0 - 1 + 4 * G4;
        const z4 = z0 - 1 + 4 * G4;
        const w4 = w0 - 1 + 4 * G4;

        const ii = i & 255;
        const jj = j & 255;
        const kk = k & 255;
        const ll = l & 255;

        const gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;
        const gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;
        const gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32;
        const gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;
        const gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32;

        let n0 = 0;
        let n1 = 0;
        let n2 = 0;
        let n3 = 0;
        let n4 = 0;

        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
        if (t0 > 0) {
          t0 *= t0;
          n0 = t0 * t0 * dot(grad4[gi0], x0, y0, z0, w0);
        }

        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
        if (t1 > 0) {
          t1 *= t1;
          n1 = t1 * t1 * dot(grad4[gi1], x1, y1, z1, w1);
        }

        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
        if (t2 > 0) {
          t2 *= t2;
          n2 = t2 * t2 * dot(grad4[gi2], x2, y2, z2, w2);
        }

        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
        if (t3 > 0) {
          t3 *= t3;
          n3 = t3 * t3 * dot(grad4[gi3], x3, y3, z3, w3);
        }

        let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
        if (t4 > 0) {
          t4 *= t4;
          n4 = t4 * t4 * dot(grad4[gi4], x4, y4, z4, w4);
        }

        return 27 * (n0 + n1 + n2 + n3 + n4);
      }

      function clampFlagsPosition() {
        const titleRect = flags.getBoundingClientRect();
        const maxX = Math.max(0, window.innerWidth - titleRect.width);
        const maxY = Math.max(0, window.innerHeight - titleRect.height);
        state.x = Math.min(maxX, Math.max(0, state.x));
        state.y = Math.min(maxY, Math.max(0, state.y));
      }

      function resize() {
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        canvas.width = Math.floor(window.innerWidth * dpr);
        canvas.height = Math.floor(window.innerHeight * dpr);
        canvas.style.width = `${window.innerWidth}px`;
        canvas.style.height = `${window.innerHeight}px`;
        ctx.setTransform(1, 0, 0, 1, 0, 0);

        // Keep text visible after viewport changes.
        clampFlagsPosition();

        // Render noise at lower internal resolution to avoid per-frame memory pressure.
        const maxPixels = 230000;
        const targetPixels = canvas.width * canvas.height;
        const downscale = Math.max(1, Math.sqrt(targetPixels / maxPixels));
        noiseWidth = Math.max(96, Math.floor(canvas.width / downscale));
        noiseHeight = Math.max(54, Math.floor(canvas.height / downscale));

        noiseBuffer.width = noiseWidth;
        noiseBuffer.height = noiseHeight;
        noiseImageData = noiseCtx.createImageData(noiseWidth, noiseHeight);
        noiseData = noiseImageData.data;
      }

      function changeFlagsColor() {
        state.hue = (state.hue + 47 + Math.random() * 180) % 360;
        flags.style.color = `hsl(${state.hue.toFixed(1)}deg 95% 62%)`;
      }

      flags.addEventListener('click', changeFlagsColor);
      window.addEventListener('resize', resize);
      resize();
      changeFlagsColor();

      let last = performance.now();

      function frame(now) {
        const dt = Math.min((now - last) / 1000, 0.05);
        last = now;
        state.t += dt;

        // Move and bounce the title within viewport bounds.
        state.x += state.vx * dt;
        state.y += state.vy * dt;

        const titleRect = flags.getBoundingClientRect();
        const maxX = Math.max(0, window.innerWidth - titleRect.width);
        const maxY = Math.max(0, window.innerHeight - titleRect.height);

        if (state.x <= 0) {
          state.x = 0;
          state.vx = Math.abs(state.vx);
        } else if (state.x >= maxX) {
          state.x = maxX;
          state.vx = -Math.abs(state.vx);
        }

        if (state.y <= 0) {
          state.y = 0;
          state.vy = Math.abs(state.vy);
        } else if (state.y >= maxY) {
          state.y = maxY;
          state.vy = -Math.abs(state.vy);
        }

        flags.style.transform = `translate3d(${state.x}px, ${state.y}px, 0)`;

        // Animated 4D simplex background.
        if (!noiseData) {
          requestAnimationFrame(frame);
          return;
        }

        const scale = 0.012;
        const timeFreq = state.t * 0.35;

        for (let py = 0; py < noiseHeight; py++) {
          for (let px = 0; px < noiseWidth; px++) {
            const i = (py * noiseWidth + px) * 4;
            const nx = px * scale;
            const ny = py * scale;

            const n1 = simplex4D(nx, ny, timeFreq, 0.0);
            const n2 = simplex4D(nx * 1.8, ny * 1.8, 2.7, timeFreq * 1.4);
            const n3 = simplex4D(nx * 3.2, ny * 3.2, 5.4, timeFreq * 2.1);
            const value = Math.max(-1, Math.min(1, n1 * 0.62 + n2 * 0.28 + n3 * 0.1));
            const v = Math.floor((value * 0.5 + 0.5) * 255);

            noiseData[i] = Math.min(255, 30 + v * 0.3);
            noiseData[i + 1] = Math.min(255, 40 + v * 0.45);
            noiseData[i + 2] = Math.min(255, 75 + v * 0.7);
            noiseData[i + 3] = 255;
          }
        }

        noiseCtx.putImageData(noiseImageData, 0, 0);
        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(noiseBuffer, 0, 0, canvas.width, canvas.height);
        requestAnimationFrame(frame);
      }

      requestAnimationFrame((t0) => {
        const titleRect = flags.getBoundingClientRect();
        const maxX = Math.max(0, window.innerWidth - titleRect.width);
        const maxY = Math.max(0, window.innerHeight - titleRect.height);
        state.x = Math.random() * maxX;
        state.y = Math.random() * maxY;
        clampFlagsPosition();
        last = t0;
        frame(t0);
      });
    </script>
  </body>
</html>
