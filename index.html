<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Isometric Cloud Cycle</title>
    <style>
      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: linear-gradient(#8dc8ff, #dff2ff);
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        touch-action: none;
      }

      #hud {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 10;
        color: #f5fbff;
        background: rgb(10 30 52 / 72%);
        border-radius: 10px;
        padding: 10px 12px;
        font-size: 0.86rem;
        line-height: 1.35;
      }

      #hud strong {
        color: #bde8ff;
      }

      #settings {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 11;
        color: #ecf8ff;
        background: rgb(10 30 52 / 72%);
        border-radius: 10px;
        border: 1px solid rgb(189 232 255 / 35%);
        min-width: 172px;
      }

      #settings summary {
        list-style: none;
        cursor: pointer;
        user-select: none;
        font-size: 1.1rem;
        padding: 8px 10px;
      }

      #settings summary::-webkit-details-marker {
        display: none;
      }

      #settings-panel {
        padding: 0 10px 10px;
        font-size: 0.85rem;
      }

      #settings-panel label {
        display: block;
        margin-bottom: 6px;
      }

      #settings-panel input {
        width: 100%;
      }
    </style>
  </head>
  <body>
    <div id="hud">
      <div><strong>Isometric Cloud Cycle</strong></div>
      <div>Move: WASD / Arrows / Click-or-Tap</div>
      <div>Water grows cloud • Mountains trigger rain</div>
    </div>

    <details id="settings">
      <summary aria-label="Settings">⚙️</summary>
      <div id="settings-panel">
        <label for="view-angle">View angle: <span id="view-angle-value">45°</span></label>
        <input id="view-angle" type="range" min="20" max="80" step="1" value="45" />
      </div>
    </details>

    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js';

      const CONFIG = {
        seed: 1337,
        chunkSize: 30,
        tileSize: 2,
        loadRadius: 4,
        unloadRadius: 6,
        waterLevel: 2.2,
        moveSpeed: 17,
        mountainRainHeight: 10.5,
        minCloudScale: 0.72,
        maxCloudScale: 1.82,
        minCloudWaterClearance: 3.4,
        viewAngleDeg: 45,
      };

      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0xd4ebff, 150, 460);

      const frustumSize = 58;
      const camera = new THREE.OrthographicCamera();
      const updateCameraProjection = () => {
        const aspect = window.innerWidth / window.innerHeight;
        camera.left = (-frustumSize * aspect) / 2;
        camera.right = (frustumSize * aspect) / 2;
        camera.top = frustumSize / 2;
        camera.bottom = -frustumSize / 2;
        camera.near = -500;
        camera.far = 1200;
        camera.updateProjectionMatrix();
      };
      updateCameraProjection();

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.6));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      scene.add(new THREE.HemisphereLight(0xd8eeff, 0x54784e, 0.52));
      const sun = new THREE.DirectionalLight(0xffffff, 1.28);
      sun.position.set(110, 160, 70);
      sun.castShadow = true;
      sun.shadow.mapSize.set(2048, 2048);
      sun.shadow.camera.left = -180;
      sun.shadow.camera.right = 180;
      sun.shadow.camera.top = 180;
      sun.shadow.camera.bottom = -180;
      sun.shadow.camera.near = 20;
      sun.shadow.camera.far = 520;
      scene.add(sun);
      scene.add(sun.target);

      const terrainMaterial = new THREE.MeshStandardMaterial({
        vertexColors: true,
        flatShading: true,
        roughness: 0.98,
      });
      const waterMaterial = new THREE.MeshStandardMaterial({
        color: 0x9bdcff,
        roughness: 0.1,
        metalness: 0.05,
        transparent: true,
        opacity: 0.62,
      });

      const trunkGeom = new THREE.CylinderGeometry(0.14, 0.18, 1.3, 5);
      const crownGeom = new THREE.ConeGeometry(0.68, 1.45, 6);
      const trunkMat = new THREE.MeshStandardMaterial({ color: 0x6a4327, flatShading: true });
      const crownMat = new THREE.MeshStandardMaterial({ color: 0x2f8f4a, flatShading: true });

      function hashRand(a, b) {
        const n = Math.sin(a * 129.91 + b * 217.37 + CONFIG.seed * 0.1) * 43758.5453123;
        return n - Math.floor(n);
      }

      const cloud = new THREE.Group();
      const cloudMat = new THREE.MeshStandardMaterial({ color: 0xf5fbff, flatShading: true });
      const cloudSpheres = [];
      for (let i = 0; i < 30; i++) {
        const seedX = hashRand(i * 1.1 + 5.7, 0.0) * 2 - 1;
        const seedY = hashRand(i * 2.3 + 8.4, 1.0) * 2 - 1;
        const seedZ = hashRand(i * 3.7 + 2.2, 2.0) * 2 - 1;
        const off = new THREE.Vector3(seedX, seedY * 0.6, seedZ).normalize().multiplyScalar(2.5 + hashRand(i, 3.0) * 1.7);
        const baseSize = 0.2 + hashRand(i * 4.9, 4.0) * 0.75;
        const sphere = new THREE.Mesh(new THREE.IcosahedronGeometry(1, 0), cloudMat);
        sphere.castShadow = true;
        cloud.add(sphere);
        cloudSpheres.push({
          offset: off,
          baseSize,
          phase: i * 0.133,
          mesh: sphere,
        });
      }
      scene.add(cloud);

      const vaporCount = 36;
      const vaporGeom = new THREE.BufferGeometry();
      const vaporPos = new Float32Array(vaporCount * 3);
      const vaporVel = new Float32Array(vaporCount);
      for (let i = 0; i < vaporCount; i++) {
        vaporPos[i * 3] = (Math.random() - 0.5) * 2.2;
        vaporPos[i * 3 + 1] = -1.8 - Math.random() * 1.2;
        vaporPos[i * 3 + 2] = (Math.random() - 0.5) * 2.2;
        vaporVel[i] = 0.45 + Math.random() * 0.8;
      }
      vaporGeom.setAttribute('position', new THREE.BufferAttribute(vaporPos, 3));
      const vaporMat = new THREE.PointsMaterial({ color: 0xbceeff, size: 0.08, transparent: true, opacity: 0.68 });
      const vapor = new THREE.Points(vaporGeom, vaporMat);
      vapor.visible = false;
      cloud.add(vapor);

      const rainGeom = new THREE.BufferGeometry();
      const rainCount = 84;
      const rainPos = new Float32Array(rainCount * 3);
      const rainVel = new Float32Array(rainCount);
      for (let i = 0; i < rainCount; i++) {
        rainPos[i * 3] = (Math.random() - 0.5) * 3.2;
        rainPos[i * 3 + 1] = -Math.random() * 4.2;
        rainPos[i * 3 + 2] = (Math.random() - 0.5) * 3.2;
        rainVel[i] = 4 + Math.random() * 3.2;
      }
      rainGeom.setAttribute('position', new THREE.BufferAttribute(rainPos, 3));
      const rainMat = new THREE.PointsMaterial({ color: 0x90b4c8, size: 0.08, transparent: true, opacity: 0.8 });
      const rain = new THREE.Points(rainGeom, rainMat);
      rain.visible = false;
      cloud.add(rain);
      const chunks = new Map();
      const chunkRoot = new THREE.Group();
      scene.add(chunkRoot);
      const tempObj = new THREE.Object3D();

      const keyState = new Set();
      window.addEventListener('keydown', (e) => keyState.add(e.key.toLowerCase()));
      window.addEventListener('keyup', (e) => keyState.delete(e.key.toLowerCase()));

      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();
      const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const clickMoveTarget = new THREE.Vector3();
      let hasClickTarget = false;

      const viewAngleInput = document.getElementById('view-angle');
      const viewAngleValue = document.getElementById('view-angle-value');
      viewAngleInput.addEventListener('input', () => {
        CONFIG.viewAngleDeg = Number(viewAngleInput.value);
        viewAngleValue.textContent = `${CONFIG.viewAngleDeg}°`;
      });

      function hash2(x, z, seed) {
        const s = Math.sin(x * 127.1 + z * 311.7 + seed * 71.1) * 43758.5453123;
        return s - Math.floor(s);
      }

      function valueNoise2(x, z, seed) {
        const x0 = Math.floor(x);
        const z0 = Math.floor(z);
        const fx = x - x0;
        const fz = z - z0;
        const fade = (t) => t * t * (3 - 2 * t);

        const a = hash2(x0, z0, seed);
        const b = hash2(x0 + 1, z0, seed);
        const c = hash2(x0, z0 + 1, seed);
        const d = hash2(x0 + 1, z0 + 1, seed);

        const ix1 = a + (b - a) * fade(fx);
        const ix2 = c + (d - c) * fade(fx);
        return ix1 + (ix2 - ix1) * fade(fz);
      }

      function getHeight(wx, wz) {
        // Multi-scale map: giant basins/oceans + large ranges + local details.
        const nContinent = valueNoise2(wx * 0.0045, wz * 0.0045, CONFIG.seed) * 1.2;
        const nMacro = valueNoise2(wx * 0.011, wz * 0.011, CONFIG.seed + 11) * 8.2;
        const nRidge = Math.abs(valueNoise2(wx * 0.026, wz * 0.026, CONFIG.seed + 53) - 0.5) * 17.5;
        const nDetail = valueNoise2(wx * 0.08, wz * 0.08, CONFIG.seed + 91) * 1.8;

        // depress continents to create very broad oceans (~10x screen-scale feel).
        const oceanMask = (nContinent - 0.55) * 16;
        return oceanMask + nMacro + nRidge + nDetail - 7.5;
      }

      function terrainColor(h) {
        if (h < CONFIG.waterLevel + 0.2) return new THREE.Color(0xceb889);
        if (h < 5) return new THREE.Color(0x64b861);
        if (h < 11) return new THREE.Color(0x4f9e58);
        if (h < 18) return new THREE.Color(0x70806b);
        return new THREE.Color(0xd6dde3);
      }

      function key(cx, cz) {
        return `${cx},${cz}`;
      }

      function buildChunk(cx, cz) {
        const size = CONFIG.chunkSize * CONFIG.tileSize;
        const seg = CONFIG.chunkSize;
        const group = new THREE.Group();

        const geom = new THREE.PlaneGeometry(size, size, seg, seg);
        geom.rotateX(-Math.PI / 2);
        const pos = geom.attributes.position;
        const colors = new Float32Array(pos.count * 3);
        for (let i = 0; i < pos.count; i++) {
          const lx = pos.getX(i);
          const lz = pos.getZ(i);
          const wx = cx * size + lx;
          const wz = cz * size + lz;
          const h = getHeight(wx, wz);
          pos.setY(i, h);
          const c = terrainColor(h);
          colors[i * 3] = c.r;
          colors[i * 3 + 1] = c.g;
          colors[i * 3 + 2] = c.b;
        }
        geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geom.computeVertexNormals();

        const terrain = new THREE.Mesh(geom, terrainMaterial);
        terrain.position.set(cx * size, 0, cz * size);
        terrain.receiveShadow = true;
        group.add(terrain);

        const water = new THREE.Mesh(new THREE.PlaneGeometry(size, size, 1, 1), waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.position.set(cx * size, CONFIG.waterLevel, cz * size);
        water.receiveShadow = true;
        group.add(water);

        const treeBase = Math.floor(10 + hash2(cx, cz, CONFIG.seed + 200) * 20);
        const trunks = new THREE.InstancedMesh(trunkGeom, trunkMat, treeBase);
        const crowns = new THREE.InstancedMesh(crownGeom, crownMat, treeBase);
        trunks.castShadow = true;
        trunks.receiveShadow = true;
        crowns.castShadow = true;

        let count = 0;
        for (let i = 0; i < treeBase; i++) {
          const tx = (hash2(i + 2.7, cx + 6.3, CONFIG.seed + 401) - 0.5) * size;
          const tz = (hash2(i + 9.1, cz + 3.9, CONFIG.seed + 402) - 0.5) * size;
          const wx = cx * size + tx;
          const wz = cz * size + tz;
          const h = getHeight(wx, wz);
          if (h < CONFIG.waterLevel + 0.6 || h > 13.8) continue;

          const scale = 0.8 + hash2(i, cx * 13 + cz, CONFIG.seed + 460) * 1.3;
          tempObj.position.set(wx, h + 0.7 * scale, wz);
          tempObj.rotation.y = hash2(i, cz + 8.3, CONFIG.seed + 470) * Math.PI;
          tempObj.scale.setScalar(scale);
          tempObj.updateMatrix();
          trunks.setMatrixAt(count, tempObj.matrix);

          tempObj.position.set(wx, h + 1.75 * scale, wz);
          tempObj.scale.setScalar(scale);
          tempObj.updateMatrix();
          crowns.setMatrixAt(count, tempObj.matrix);
          count++;
        }

        trunks.count = count;
        crowns.count = count;
        if (count > 0) {
          trunks.instanceMatrix.needsUpdate = true;
          crowns.instanceMatrix.needsUpdate = true;
          group.add(trunks);
          group.add(crowns);
        }

        chunkRoot.add(group);
        chunks.set(key(cx, cz), group);
      }

      function updateChunks(px, pz) {
        const size = CONFIG.chunkSize * CONFIG.tileSize;
        const centerX = Math.round(px / size);
        const centerZ = Math.round(pz / size);
        const keep = new Set();

        for (let dz = -CONFIG.loadRadius; dz <= CONFIG.loadRadius; dz++) {
          for (let dx = -CONFIG.loadRadius; dx <= CONFIG.loadRadius; dx++) {
            const cx = centerX + dx;
            const cz = centerZ + dz;
            const k = key(cx, cz);
            keep.add(k);
            if (!chunks.has(k)) buildChunk(cx, cz);
          }
        }

        for (const [k, grp] of chunks) {
          const [cx, cz] = k.split(',').map(Number);
          const tooFar = Math.abs(cx - centerX) > CONFIG.unloadRadius || Math.abs(cz - centerZ) > CONFIG.unloadRadius;
          if (tooFar && !keep.has(k)) {
            chunkRoot.remove(grp);
            grp.traverse((o) => {
              if (o.geometry) o.geometry.dispose();
            });
            chunks.delete(k);
          }
        }
      }

      const player = {
        pos: new THREE.Vector3(0, getHeight(0, 0) + 10, 0),
        vel: new THREE.Vector3(),
        waterContent: 0.55,
        storminess: 0,
      };

      function pointerToGround(clientX, clientY) {
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(pointer, camera);
        const out = new THREE.Vector3();
        if (raycaster.ray.intersectPlane(groundPlane, out)) {
          clickMoveTarget.copy(out);
          hasClickTarget = true;
        }
      }

      window.addEventListener('pointerdown', (e) => pointerToGround(e.clientX, e.clientY), { passive: true });
      window.addEventListener('pointermove', (e) => {
        if (e.buttons === 1) pointerToGround(e.clientX, e.clientY);
      }, { passive: true });

      let time = 0;
      let last = performance.now();

      function animate(now) {
        const dt = Math.min((now - last) / 1000, 0.05);
        last = now;
        time += dt;

        const input = new THREE.Vector2();
        if (keyState.has('arrowup') || keyState.has('w')) input.y -= 1;
        if (keyState.has('arrowdown') || keyState.has('s')) input.y += 1;
        if (keyState.has('arrowleft') || keyState.has('a')) input.x -= 1;
        if (keyState.has('arrowright') || keyState.has('d')) input.x += 1;

        if (input.lengthSq() > 0) {
          hasClickTarget = false;
          input.normalize();
          player.vel.set(input.x * CONFIG.moveSpeed, 0, input.y * CONFIG.moveSpeed);
        } else if (hasClickTarget) {
          const to = clickMoveTarget.clone().sub(player.pos);
          to.y = 0;
          const dist = to.length();
          if (dist < 1.2) {
            hasClickTarget = false;
            player.vel.set(0, 0, 0);
          } else {
            to.normalize();
            player.vel.set(to.x * CONFIG.moveSpeed, 0, to.z * CONFIG.moveSpeed);
          }
        } else {
          player.vel.multiplyScalar(Math.max(0, 1 - dt * 8));
        }

        player.pos.x += player.vel.x * dt;
        player.pos.z += player.vel.z * dt;

        const ground = getHeight(player.pos.x, player.pos.z);
        const overWater = ground <= CONFIG.waterLevel + 0.2;
        const high = ground >= CONFIG.mountainRainHeight;

        if (overWater) player.waterContent = Math.min(1, player.waterContent + dt * 0.16);
        if (high) player.waterContent = Math.max(0, player.waterContent - dt * 0.2);

        player.storminess += ((high ? 1 : 0) - player.storminess) * Math.min(1, dt * (high ? 1.8 : 1.4));

        const cloudScale = THREE.MathUtils.lerp(CONFIG.minCloudScale, CONFIG.maxCloudScale, player.waterContent);
        cloud.scale.setScalar(cloudScale);

        const darken = Math.min(1, player.storminess * 1.2);
        const light = THREE.MathUtils.lerp(0.98, 0.34, darken);
        cloudMat.color.setRGB(light, light + 0.02, light + 0.05);

        vapor.visible = overWater;
        vaporMat.opacity = (0.15 + player.waterContent * 0.5) * (overWater ? 1 : 0);
        const vapAttr = vapor.geometry.attributes.position;
        for (let i = 0; i < vaporCount; i++) {
          vapAttr.array[i * 3 + 1] += vaporVel[i] * dt;
          vapAttr.array[i * 3] += Math.sin(time * 1.4 + i) * 0.005;
          if (vapAttr.array[i * 3 + 1] > -0.6) {
            vapAttr.array[i * 3] = (Math.random() - 0.5) * 2.0;
            vapAttr.array[i * 3 + 1] = -2.2 - Math.random() * 1.3;
            vapAttr.array[i * 3 + 2] = (Math.random() - 0.5) * 2.0;
          }
        }
        vapAttr.needsUpdate = true;

        const raining = player.storminess > 0.55 && player.waterContent > 0.16;
        rain.visible = raining;
        if (raining) {
          const attr = rain.geometry.attributes.position;
          for (let i = 0; i < rainCount; i++) {
            attr.array[i * 3 + 1] -= rainVel[i] * dt;
            if (attr.array[i * 3 + 1] < -5.2) {
              attr.array[i * 3] = (Math.random() - 0.5) * 3.1;
              attr.array[i * 3 + 1] = -0.2;
              attr.array[i * 3 + 2] = (Math.random() - 0.5) * 3.1;
            }
          }
          attr.needsUpdate = true;
        }

        const minYAboveWater = CONFIG.waterLevel + CONFIG.minCloudWaterClearance;
        const floatY = Math.max(minYAboveWater, ground + 6.6 + Math.sin(time * 2.2) * 0.26);
        player.pos.y += (floatY - player.pos.y) * Math.min(1, dt * 4.6);

        // Ripple in a stationary noise field: spheres appear/grow/shrink/vanish as cloud moves.
        const worldX = player.pos.x;
        const worldZ = player.pos.z;
        const radiusBias = THREE.MathUtils.lerp(-0.08, 0.22, player.waterContent);
        cloudSpheres.forEach((entry, i) => {
          const sx = (worldX + entry.offset.x * 4.4) * 0.1;
          const sz = (worldZ + entry.offset.z * 4.4) * 0.1;
          const field = valueNoise2(sx, sz, CONFIG.seed + 700 + (i % 3) * 31);
          const life = THREE.MathUtils.smoothstep(field + radiusBias, 0.45, 0.86);
          const pulse = 0.65 + Math.sin(time * 2.8 + entry.phase * 10) * 0.35;
          const s = entry.baseSize * life * pulse;
          entry.mesh.visible = s > 0.08;
          entry.mesh.position.copy(entry.offset);
          entry.mesh.scale.setScalar(Math.max(0.001, s));
        });

        cloud.position.copy(player.pos);

        // Non-perspective camera at configurable fixed-angle orthographic follow.
        const az = Math.PI / 4;
        const el = THREE.MathUtils.degToRad(CONFIG.viewAngleDeg);
        const dist = 86;
        const offset = new THREE.Vector3(
          Math.cos(el) * Math.cos(az) * dist,
          Math.sin(el) * dist,
          Math.cos(el) * Math.sin(az) * dist,
        );
        camera.position.copy(player.pos).add(offset);
        camera.lookAt(player.pos);

        sun.position.set(player.pos.x, player.pos.y + 170, player.pos.z);
        sun.target.position.copy(player.pos);
        sun.target.updateMatrixWorld();

        updateChunks(player.pos.x, player.pos.z);
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      updateChunks(0, 0);
      requestAnimationFrame((t0) => {
        last = t0;
        animate(t0);
      });

      window.addEventListener('resize', () => {
        updateCameraProjection();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
