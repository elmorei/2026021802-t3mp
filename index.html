<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Isometric Cloud Cycle</title>
    <style>
      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: linear-gradient(#8dc8ff, #dff2ff);
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        touch-action: none;
      }

      #hud {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 10;
        color: #f5fbff;
        background: rgb(10 30 52 / 72%);
        border-radius: 10px;
        padding: 10px 12px;
        font-size: 0.86rem;
        line-height: 1.35;
      }

      #hud strong {
        color: #bde8ff;
      }

      #settings {
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 11;
        color: #ecf8ff;
        background: rgb(10 30 52 / 72%);
        border-radius: 10px;
        border: 1px solid rgb(189 232 255 / 35%);
        min-width: 172px;
      }

      #settings summary {
        list-style: none;
        cursor: pointer;
        user-select: none;
        font-size: 1.1rem;
        padding: 8px 10px;
      }

      #settings summary::-webkit-details-marker {
        display: none;
      }

      #settings-panel {
        padding: 0 10px 10px;
        font-size: 0.85rem;
      }

      #settings-panel label {
        display: block;
        margin-bottom: 6px;
      }

      #settings-panel input {
        width: 100%;
      }
    </style>
  </head>
  <body>
    <div id="hud">
      <div><strong>Isometric Cloud Cycle</strong></div>
      <div>Move: WASD / Arrows / Click-or-Tap</div>
      <div>Water grows cloud • Mountains trigger rain</div>
    </div>

    <details id="settings">
      <summary aria-label="Settings">⚙️</summary>
      <div id="settings-panel">
        <label for="view-angle">View angle: <span id="view-angle-value">45°</span></label>
        <input id="view-angle" type="range" min="20" max="80" step="1" value="45" />
      </div>
    </details>

    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js';

      const CONFIG = {
        seed: 1337,
        chunkSize: 30,
        tileSize: 2,
        loadRadius: 4,
        unloadRadius: 6,
        waterLevel: 2.2,
        moveSpeed: 17,
        mountainRainHeight: 10.5,
        minCloudScale: 0.72,
        maxCloudScale: 1.82,
        viewAngleDeg: 45,
      };

      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0xd4ebff, 150, 460);

      const frustumSize = 58;
      const camera = new THREE.OrthographicCamera();
      const updateCameraProjection = () => {
        const aspect = window.innerWidth / window.innerHeight;
        camera.left = (-frustumSize * aspect) / 2;
        camera.right = (frustumSize * aspect) / 2;
        camera.top = frustumSize / 2;
        camera.bottom = -frustumSize / 2;
        camera.near = -500;
        camera.far = 1200;
        camera.updateProjectionMatrix();
      };
      updateCameraProjection();

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.6));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      scene.add(new THREE.HemisphereLight(0xd8eeff, 0x54784e, 0.52));
      const sun = new THREE.DirectionalLight(0xffffff, 1.28);
      sun.position.set(110, 160, 70);
      sun.castShadow = true;
      sun.shadow.mapSize.set(2048, 2048);
      sun.shadow.camera.left = -180;
      sun.shadow.camera.right = 180;
      sun.shadow.camera.top = 180;
      sun.shadow.camera.bottom = -180;
      sun.shadow.camera.near = 20;
      sun.shadow.camera.far = 520;
      scene.add(sun);
      scene.add(sun.target);

      const terrainMaterial = new THREE.MeshStandardMaterial({
        vertexColors: true,
        flatShading: true,
        roughness: 0.98,
      });
      const waterMaterial = new THREE.MeshStandardMaterial({
        color: 0x3f87b7,
        roughness: 0.2,
        metalness: 0.08,
        transparent: true,
        opacity: 0.9,
      });

      const trunkGeom = new THREE.CylinderGeometry(0.14, 0.18, 1.3, 5);
      const crownGeom = new THREE.ConeGeometry(0.68, 1.45, 6);
      const trunkMat = new THREE.MeshStandardMaterial({ color: 0x6a4327, flatShading: true });
      const crownMat = new THREE.MeshStandardMaterial({ color: 0x2f8f4a, flatShading: true });

      const cloud = new THREE.Group();
      const cloudMat = new THREE.MeshStandardMaterial({ color: 0xf5fbff, flatShading: true });
      const puffSeeds = [];
      [
        [0, 0.1, 0, 1.3],
        [1.12, 0.26, -0.24, 0.96],
        [-1.04, 0.27, 0.35, 0.92],
        [0.28, 0.72, 0.06, 0.77],
        [-0.4, 0.58, -0.82, 0.65],
      ].forEach(([x, y, z, s], i) => {
        const m = new THREE.Mesh(new THREE.IcosahedronGeometry(s, 0), cloudMat);
        m.position.set(x, y, z);
        m.castShadow = true;
        cloud.add(m);
        puffSeeds.push({
          base: new THREE.Vector3(x, y, z),
          phase: i * 13.7 + 5.1,
          mesh: m,
        });
      });
      scene.add(cloud);

      const vaporGroup = new THREE.Group();
      const vaporMat = new THREE.MeshStandardMaterial({ color: 0xcde8f8, flatShading: true, transparent: true, opacity: 0.48 });
      for (let i = 0; i < 6; i++) {
        const p = new THREE.Mesh(new THREE.IcosahedronGeometry(0.35 + (i % 3) * 0.08, 0), vaporMat);
        p.position.set((i - 2.5) * 0.42, -1.8 - (i % 2) * 0.2, Math.sin(i) * 0.25);
        vaporGroup.add(p);
      }
      vaporGroup.visible = false;
      cloud.add(vaporGroup);

      const rainGeom = new THREE.BufferGeometry();
      const rainCount = 120;
      const rainPos = new Float32Array(rainCount * 3);
      const rainVel = new Float32Array(rainCount);
      for (let i = 0; i < rainCount; i++) {
        rainPos[i * 3] = (Math.random() - 0.5) * 4;
        rainPos[i * 3 + 1] = -Math.random() * 6;
        rainPos[i * 3 + 2] = (Math.random() - 0.5) * 4;
        rainVel[i] = 4 + Math.random() * 5;
      }
      rainGeom.setAttribute('position', new THREE.BufferAttribute(rainPos, 3));
      const rainMat = new THREE.PointsMaterial({ color: 0x9fc2d8, size: 0.12, transparent: true, opacity: 0.8 });
      const rain = new THREE.Points(rainGeom, rainMat);
      rain.visible = false;
      cloud.add(rain);

      const chunks = new Map();
      const chunkRoot = new THREE.Group();
      scene.add(chunkRoot);
      const tempObj = new THREE.Object3D();

      const keyState = new Set();
      window.addEventListener('keydown', (e) => keyState.add(e.key.toLowerCase()));
      window.addEventListener('keyup', (e) => keyState.delete(e.key.toLowerCase()));

      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();
      const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      const clickMoveTarget = new THREE.Vector3();
      let hasClickTarget = false;

      const viewAngleInput = document.getElementById('view-angle');
      const viewAngleValue = document.getElementById('view-angle-value');
      viewAngleInput.addEventListener('input', () => {
        CONFIG.viewAngleDeg = Number(viewAngleInput.value);
        viewAngleValue.textContent = `${CONFIG.viewAngleDeg}°`;
      });

      function hash2(x, z, seed) {
        const s = Math.sin(x * 127.1 + z * 311.7 + seed * 71.1) * 43758.5453123;
        return s - Math.floor(s);
      }

      function valueNoise2(x, z, seed) {
        const x0 = Math.floor(x);
        const z0 = Math.floor(z);
        const fx = x - x0;
        const fz = z - z0;
        const fade = (t) => t * t * (3 - 2 * t);

        const a = hash2(x0, z0, seed);
        const b = hash2(x0 + 1, z0, seed);
        const c = hash2(x0, z0 + 1, seed);
        const d = hash2(x0 + 1, z0 + 1, seed);

        const ix1 = a + (b - a) * fade(fx);
        const ix2 = c + (d - c) * fade(fx);
        return ix1 + (ix2 - ix1) * fade(fz);
      }

      function getHeight(wx, wz) {
        // Multi-scale map: giant basins/oceans + large ranges + local details.
        const nContinent = valueNoise2(wx * 0.0045, wz * 0.0045, CONFIG.seed) * 1.2;
        const nMacro = valueNoise2(wx * 0.011, wz * 0.011, CONFIG.seed + 11) * 8.2;
        const nRidge = Math.abs(valueNoise2(wx * 0.026, wz * 0.026, CONFIG.seed + 53) - 0.5) * 17.5;
        const nDetail = valueNoise2(wx * 0.08, wz * 0.08, CONFIG.seed + 91) * 1.8;

        // depress continents to create very broad oceans (~10x screen-scale feel).
        const oceanMask = (nContinent - 0.55) * 16;
        return oceanMask + nMacro + nRidge + nDetail - 7.5;
      }

      function terrainColor(h) {
        if (h < CONFIG.waterLevel + 0.2) return new THREE.Color(0xceb889);
        if (h < 5) return new THREE.Color(0x64b861);
        if (h < 11) return new THREE.Color(0x4f9e58);
        if (h < 18) return new THREE.Color(0x70806b);
        return new THREE.Color(0xd6dde3);
      }

      function key(cx, cz) {
        return `${cx},${cz}`;
      }

      function buildChunk(cx, cz) {
        const size = CONFIG.chunkSize * CONFIG.tileSize;
        const seg = CONFIG.chunkSize;
        const group = new THREE.Group();

        const geom = new THREE.PlaneGeometry(size, size, seg, seg);
        geom.rotateX(-Math.PI / 2);
        const pos = geom.attributes.position;
        const colors = new Float32Array(pos.count * 3);
        for (let i = 0; i < pos.count; i++) {
          const lx = pos.getX(i);
          const lz = pos.getZ(i);
          const wx = cx * size + lx;
          const wz = cz * size + lz;
          const h = getHeight(wx, wz);
          pos.setY(i, h);
          const c = terrainColor(h);
          colors[i * 3] = c.r;
          colors[i * 3 + 1] = c.g;
          colors[i * 3 + 2] = c.b;
        }
        geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geom.computeVertexNormals();

        const terrain = new THREE.Mesh(geom, terrainMaterial);
        terrain.position.set(cx * size, 0, cz * size);
        terrain.receiveShadow = true;
        group.add(terrain);

        const water = new THREE.Mesh(new THREE.PlaneGeometry(size, size, 1, 1), waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.position.set(cx * size, CONFIG.waterLevel, cz * size);
        water.receiveShadow = true;
        group.add(water);

        const treeBase = Math.floor(10 + hash2(cx, cz, CONFIG.seed + 200) * 20);
        const trunks = new THREE.InstancedMesh(trunkGeom, trunkMat, treeBase);
        const crowns = new THREE.InstancedMesh(crownGeom, crownMat, treeBase);
        trunks.castShadow = true;
        trunks.receiveShadow = true;
        crowns.castShadow = true;

        let count = 0;
        for (let i = 0; i < treeBase; i++) {
          const tx = (hash2(i + 2.7, cx + 6.3, CONFIG.seed + 401) - 0.5) * size;
          const tz = (hash2(i + 9.1, cz + 3.9, CONFIG.seed + 402) - 0.5) * size;
          const wx = cx * size + tx;
          const wz = cz * size + tz;
          const h = getHeight(wx, wz);
          if (h < CONFIG.waterLevel + 0.6 || h > 13.8) continue;

          const scale = 0.8 + hash2(i, cx * 13 + cz, CONFIG.seed + 460) * 1.3;
          tempObj.position.set(wx, h + 0.7 * scale, wz);
          tempObj.rotation.y = hash2(i, cz + 8.3, CONFIG.seed + 470) * Math.PI;
          tempObj.scale.setScalar(scale);
          tempObj.updateMatrix();
          trunks.setMatrixAt(count, tempObj.matrix);

          tempObj.position.set(wx, h + 1.75 * scale, wz);
          tempObj.scale.setScalar(scale);
          tempObj.updateMatrix();
          crowns.setMatrixAt(count, tempObj.matrix);
          count++;
        }

        trunks.count = count;
        crowns.count = count;
        if (count > 0) {
          trunks.instanceMatrix.needsUpdate = true;
          crowns.instanceMatrix.needsUpdate = true;
          group.add(trunks);
          group.add(crowns);
        }

        chunkRoot.add(group);
        chunks.set(key(cx, cz), group);
      }

      function updateChunks(px, pz) {
        const size = CONFIG.chunkSize * CONFIG.tileSize;
        const centerX = Math.round(px / size);
        const centerZ = Math.round(pz / size);
        const keep = new Set();

        for (let dz = -CONFIG.loadRadius; dz <= CONFIG.loadRadius; dz++) {
          for (let dx = -CONFIG.loadRadius; dx <= CONFIG.loadRadius; dx++) {
            const cx = centerX + dx;
            const cz = centerZ + dz;
            const k = key(cx, cz);
            keep.add(k);
            if (!chunks.has(k)) buildChunk(cx, cz);
          }
        }

        for (const [k, grp] of chunks) {
          const [cx, cz] = k.split(',').map(Number);
          const tooFar = Math.abs(cx - centerX) > CONFIG.unloadRadius || Math.abs(cz - centerZ) > CONFIG.unloadRadius;
          if (tooFar && !keep.has(k)) {
            chunkRoot.remove(grp);
            grp.traverse((o) => {
              if (o.geometry) o.geometry.dispose();
            });
            chunks.delete(k);
          }
        }
      }

      const player = {
        pos: new THREE.Vector3(0, getHeight(0, 0) + 8, 0),
        vel: new THREE.Vector3(),
        waterContent: 0.55,
      };

      function pointerToGround(clientX, clientY) {
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(pointer, camera);
        const out = new THREE.Vector3();
        if (raycaster.ray.intersectPlane(groundPlane, out)) {
          clickMoveTarget.copy(out);
          hasClickTarget = true;
        }
      }

      window.addEventListener('pointerdown', (e) => pointerToGround(e.clientX, e.clientY), { passive: true });
      window.addEventListener('pointermove', (e) => {
        if (e.buttons === 1) pointerToGround(e.clientX, e.clientY);
      }, { passive: true });

      let time = 0;
      let last = performance.now();

      function animate(now) {
        const dt = Math.min((now - last) / 1000, 0.05);
        last = now;
        time += dt;

        const input = new THREE.Vector2();
        if (keyState.has('arrowup') || keyState.has('w')) input.y -= 1;
        if (keyState.has('arrowdown') || keyState.has('s')) input.y += 1;
        if (keyState.has('arrowleft') || keyState.has('a')) input.x -= 1;
        if (keyState.has('arrowright') || keyState.has('d')) input.x += 1;

        if (input.lengthSq() > 0) {
          hasClickTarget = false;
          input.normalize();
          player.vel.set(input.x * CONFIG.moveSpeed, 0, input.y * CONFIG.moveSpeed);
        } else if (hasClickTarget) {
          const to = clickMoveTarget.clone().sub(player.pos);
          to.y = 0;
          const dist = to.length();
          if (dist < 1.2) {
            hasClickTarget = false;
            player.vel.set(0, 0, 0);
          } else {
            to.normalize();
            player.vel.set(to.x * CONFIG.moveSpeed, 0, to.z * CONFIG.moveSpeed);
          }
        } else {
          player.vel.multiplyScalar(Math.max(0, 1 - dt * 8));
        }

        player.pos.x += player.vel.x * dt;
        player.pos.z += player.vel.z * dt;

        const ground = getHeight(player.pos.x, player.pos.z);
        const overWater = ground <= CONFIG.waterLevel + 0.2;
        const high = ground >= CONFIG.mountainRainHeight;

        if (overWater) {
          player.waterContent = Math.min(1, player.waterContent + dt * 0.18);
        }
        if (high) {
          player.waterContent = Math.max(0, player.waterContent - dt * 0.22);
        }

        const cloudScale = THREE.MathUtils.lerp(CONFIG.minCloudScale, CONFIG.maxCloudScale, player.waterContent);
        cloud.scale.setScalar(cloudScale);

        vaporGroup.visible = overWater;
        vaporMat.opacity = 0.22 + player.waterContent * 0.45;
        vaporGroup.rotation.y += dt * 0.4;

        const raining = high && player.waterContent > 0.2;
        rain.visible = raining;
        if (raining) {
          const attr = rain.geometry.attributes.position;
          for (let i = 0; i < rainCount; i++) {
            attr.array[i * 3] += Math.sin(time * 1.7 + i) * 0.004;
            attr.array[i * 3 + 1] -= rainVel[i] * dt;
            if (attr.array[i * 3 + 1] < -7) {
              attr.array[i * 3 + 1] = -0.4 - Math.random() * 1.8;
            }
          }
          attr.needsUpdate = true;
        }

        const brightness = 0.34 + player.waterContent * 0.66;
        cloudMat.color.setRGB(brightness, brightness + 0.01, brightness + 0.04);

        const floatY = ground + 6 + Math.sin(time * 2.2) * 0.28;
        player.pos.y += (floatY - player.pos.y) * Math.min(1, dt * 5);

        // 4D-like ripple motion driven by pseudo-noise in time + movement.
        const speed = Math.hypot(player.vel.x, player.vel.z);
        puffSeeds.forEach((seed, i) => {
          const waveA = valueNoise2((time * 0.7 + seed.phase) * 0.9, speed * 0.18 + i, CONFIG.seed + 900);
          const waveB = valueNoise2((time * 1.1 + seed.phase) * 1.2, player.pos.x * 0.02 + i, CONFIG.seed + 901);
          const ripple = (waveA + waveB - 1) * 0.36 * (0.25 + speed * 0.03);
          seed.mesh.position.copy(seed.base).addScaledVector(seed.base.clone().normalize(), ripple);
        });

        cloud.position.copy(player.pos);
        cloud.rotation.y += dt * 0.18;

        // Non-perspective camera at configurable fixed-angle orthographic follow.
        const az = Math.PI / 4;
        const el = THREE.MathUtils.degToRad(CONFIG.viewAngleDeg);
        const dist = 86;
        const offset = new THREE.Vector3(
          Math.cos(el) * Math.cos(az) * dist,
          Math.sin(el) * dist,
          Math.cos(el) * Math.sin(az) * dist,
        );
        camera.position.copy(player.pos).add(offset);
        camera.lookAt(player.pos);

        sun.position.set(player.pos.x + 110, 160, player.pos.z + 70);
        sun.target.position.copy(player.pos);
        sun.target.updateMatrixWorld();

        updateChunks(player.pos.x, player.pos.z);
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      updateChunks(0, 0);
      requestAnimationFrame((t0) => {
        last = t0;
        animate(t0);
      });

      window.addEventListener('resize', () => {
        updateCameraProjection();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
