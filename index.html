<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lowpoly Cloud Explorer</title>
    <style>
      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: linear-gradient(#8ec9ff, #dff1ff);
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      }

      #hud {
        position: fixed;
        top: 12px;
        left: 12px;
        z-index: 10;
        padding: 10px 12px;
        border-radius: 10px;
        background: rgb(12 32 54 / 70%);
        color: #f4fbff;
        backdrop-filter: blur(4px);
        font-size: 0.9rem;
        line-height: 1.35;
      }

      #hud strong {
        color: #bfe7ff;
      }
    </style>
  </head>
  <body>
    <div id="hud">
      <div><strong>Cloud Explorer</strong></div>
      <div>Move: WASD / Arrows</div>
      <div>Terrain: procedural + infinite chunks</div>
    </div>

    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js';

      const CONFIG = {
        seed: 1337,
        chunkSize: 28,
        tileSize: 2,
        chunkRadius: 2,
        heightScale: 9,
        waterLevel: 1.6,
        treeLineMin: 2.4,
        treeLineMax: 8.4,
        maxTreesPerChunk: 28,
        moveSpeed: 15,
        cameraHeight: 26,
        cameraDistance: 26,
      };

      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0xd7eeff, 65, 210);

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1200);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.7));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      scene.add(new THREE.HemisphereLight(0xd8efff, 0x5d8660, 0.9));
      const sun = new THREE.DirectionalLight(0xffffff, 1.08);
      sun.position.set(30, 55, 24);
      sun.castShadow = true;
      sun.shadow.mapSize.set(1024, 1024);
      sun.shadow.camera.near = 5;
      sun.shadow.camera.far = 180;
      sun.shadow.camera.left = -70;
      sun.shadow.camera.right = 70;
      sun.shadow.camera.top = 70;
      sun.shadow.camera.bottom = -70;
      scene.add(sun);

      const waterMaterial = new THREE.MeshStandardMaterial({
        color: 0x4b93c7,
        roughness: 0.2,
        metalness: 0.1,
        transparent: true,
        opacity: 0.88,
      });

      const terrainMaterial = new THREE.MeshStandardMaterial({
        vertexColors: true,
        flatShading: true,
        roughness: 1,
        metalness: 0,
      });

      const trunkGeom = new THREE.CylinderGeometry(0.14, 0.16, 1.2, 5);
      const crownGeom = new THREE.ConeGeometry(0.58, 1.3, 5);
      const trunkMat = new THREE.MeshStandardMaterial({ color: 0x6a4a2b, flatShading: true });
      const crownMat = new THREE.MeshStandardMaterial({ color: 0x2b8f47, flatShading: true });

      const cloud = new THREE.Group();
      const puffMat = new THREE.MeshStandardMaterial({ color: 0xffffff, flatShading: true });
      [
        [0, 0, 0, 1.2],
        [1.05, 0.25, -0.25, 0.9],
        [-1.0, 0.2, 0.2, 0.85],
        [0.18, 0.62, 0.1, 0.75],
      ].forEach(([x, y, z, s]) => {
        const m = new THREE.Mesh(new THREE.IcosahedronGeometry(s, 0), puffMat);
        m.position.set(x, y, z);
        m.castShadow = true;
        cloud.add(m);
      });
      scene.add(cloud);

      const keyState = new Set();
      window.addEventListener('keydown', (e) => keyState.add(e.key.toLowerCase()));
      window.addEventListener('keyup', (e) => keyState.delete(e.key.toLowerCase()));

      const chunkRoot = new THREE.Group();
      scene.add(chunkRoot);

      const chunks = new Map();
      const tempObj = new THREE.Object3D();

      function hash2(x, z, seed) {
        const s = Math.sin((x * 127.1 + z * 311.7 + seed * 17.13)) * 43758.5453123;
        return s - Math.floor(s);
      }

      function valueNoise2(x, z, seed) {
        const x0 = Math.floor(x);
        const z0 = Math.floor(z);
        const xf = x - x0;
        const zf = z - z0;
        const smooth = (t) => t * t * (3 - 2 * t);

        const a = hash2(x0, z0, seed);
        const b = hash2(x0 + 1, z0, seed);
        const c = hash2(x0, z0 + 1, seed);
        const d = hash2(x0 + 1, z0 + 1, seed);

        const sx = smooth(xf);
        const sz = smooth(zf);
        const i1 = a + (b - a) * sx;
        const i2 = c + (d - c) * sx;
        return i1 + (i2 - i1) * sz;
      }

      function getHeight(worldX, worldZ) {
        // Layered procedural height map, intentionally configurable for future biome expansion.
        const nx = worldX * 0.055;
        const nz = worldZ * 0.055;
        const n1 = valueNoise2(nx, nz, CONFIG.seed);
        const n2 = valueNoise2(nx * 2.1, nz * 2.1, CONFIG.seed + 71) * 0.5;
        const n3 = valueNoise2(nx * 4.2, nz * 4.2, CONFIG.seed + 173) * 0.22;
        const combined = n1 + n2 + n3;
        return combined * CONFIG.heightScale;
      }

      function terrainColorForHeight(h) {
        if (h < CONFIG.waterLevel + 0.35) return new THREE.Color(0xd9c69d);
        if (h < 3.2) return new THREE.Color(0x6ebc68);
        if (h < 6.2) return new THREE.Color(0x53a458);
        if (h < 8.8) return new THREE.Color(0x7f8a72);
        return new THREE.Color(0xcfd6db);
      }

      function chunkKey(cx, cz) {
        return `${cx},${cz}`;
      }

      function buildChunk(cx, cz) {
        const group = new THREE.Group();
        const seg = CONFIG.chunkSize;
        const size = CONFIG.chunkSize * CONFIG.tileSize;
        const geom = new THREE.PlaneGeometry(size, size, seg, seg);
        geom.rotateX(-Math.PI / 2);
        const pos = geom.attributes.position;
        const color = new Float32Array(pos.count * 3);

        for (let i = 0; i < pos.count; i++) {
          const localX = pos.getX(i);
          const localZ = pos.getZ(i);
          const wx = cx * size + localX;
          const wz = cz * size + localZ;
          const h = getHeight(wx, wz);
          pos.setY(i, h);
          const c = terrainColorForHeight(h);
          color[i * 3] = c.r;
          color[i * 3 + 1] = c.g;
          color[i * 3 + 2] = c.b;
        }
        geom.setAttribute('color', new THREE.BufferAttribute(color, 3));
        geom.computeVertexNormals();

        const terrain = new THREE.Mesh(geom, terrainMaterial);
        terrain.castShadow = false;
        terrain.receiveShadow = true;
        terrain.position.set(cx * size, 0, cz * size);
        group.add(terrain);

        const water = new THREE.Mesh(new THREE.PlaneGeometry(size, size, 1, 1), waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.position.set(cx * size, CONFIG.waterLevel, cz * size);
        water.receiveShadow = true;
        group.add(water);

        const rand = (a, b, s) => a + (b - a) * hash2(cx * 1000 + a, cz * 1000 + b, CONFIG.seed + s);
        const treeCount = Math.floor(rand(CONFIG.maxTreesPerChunk * 0.35, CONFIG.maxTreesPerChunk, 201));
        const trunks = new THREE.InstancedMesh(trunkGeom, trunkMat, treeCount);
        const crowns = new THREE.InstancedMesh(crownGeom, crownMat, treeCount);
        trunks.castShadow = true;
        trunks.receiveShadow = true;
        crowns.castShadow = true;
        crowns.receiveShadow = true;

        let actual = 0;
        for (let i = 0; i < treeCount; i++) {
          const tx = (hash2(i, cx + 13, CONFIG.seed + 22) - 0.5) * size;
          const tz = (hash2(i, cz + 19, CONFIG.seed + 47) - 0.5) * size;
          const wx = cx * size + tx;
          const wz = cz * size + tz;
          const h = getHeight(wx, wz);
          if (h < CONFIG.treeLineMin || h > CONFIG.treeLineMax || h < CONFIG.waterLevel + 0.2) continue;

          const scale = 0.85 + hash2(i, cx * 7 + cz * 3, CONFIG.seed + 301) * 0.9;

          tempObj.position.set(cx * size + tx, h + 0.6 * scale, cz * size + tz);
          tempObj.rotation.y = hash2(i, cz, CONFIG.seed + 511) * Math.PI;
          tempObj.scale.setScalar(scale);
          tempObj.updateMatrix();
          trunks.setMatrixAt(actual, tempObj.matrix);

          tempObj.position.set(cx * size + tx, h + 1.55 * scale, cz * size + tz);
          tempObj.scale.setScalar(scale);
          tempObj.updateMatrix();
          crowns.setMatrixAt(actual, tempObj.matrix);
          actual++;
        }

        trunks.count = actual;
        crowns.count = actual;
        if (actual > 0) {
          trunks.instanceMatrix.needsUpdate = true;
          crowns.instanceMatrix.needsUpdate = true;
          group.add(trunks);
          group.add(crowns);
        }

        chunkRoot.add(group);
        chunks.set(chunkKey(cx, cz), group);
      }

      function updateChunks(centerX, centerZ) {
        const size = CONFIG.chunkSize * CONFIG.tileSize;
        const ccx = Math.round(centerX / size);
        const ccz = Math.round(centerZ / size);
        const keep = new Set();

        for (let dz = -CONFIG.chunkRadius; dz <= CONFIG.chunkRadius; dz++) {
          for (let dx = -CONFIG.chunkRadius; dx <= CONFIG.chunkRadius; dx++) {
            const cx = ccx + dx;
            const cz = ccz + dz;
            const key = chunkKey(cx, cz);
            keep.add(key);
            if (!chunks.has(key)) buildChunk(cx, cz);
          }
        }

        for (const [key, grp] of chunks) {
          if (!keep.has(key)) {
            chunkRoot.remove(grp);
            grp.traverse((o) => {
              if (o.geometry) o.geometry.dispose();
            });
            chunks.delete(key);
          }
        }
      }

      const player = {
        pos: new THREE.Vector3(0, getHeight(0, 0) + 7, 0),
        vel: new THREE.Vector3(),
      };

      const cameraOffset = new THREE.Vector3(-CONFIG.cameraDistance, CONFIG.cameraHeight, CONFIG.cameraDistance);
      const cameraLookAhead = new THREE.Vector3(0, 2, 0);

      let time = 0;
      let last = performance.now();

      function animate(now) {
        const dt = Math.min((now - last) / 1000, 0.04);
        last = now;
        time += dt;

        const input = new THREE.Vector2(0, 0);
        if (keyState.has('arrowup') || keyState.has('w')) input.y -= 1;
        if (keyState.has('arrowdown') || keyState.has('s')) input.y += 1;
        if (keyState.has('arrowleft') || keyState.has('a')) input.x -= 1;
        if (keyState.has('arrowright') || keyState.has('d')) input.x += 1;
        if (input.lengthSq() > 0) input.normalize();

        player.vel.x = input.x * CONFIG.moveSpeed;
        player.vel.z = input.y * CONFIG.moveSpeed;
        player.pos.x += player.vel.x * dt;
        player.pos.z += player.vel.z * dt;

        const ground = getHeight(player.pos.x, player.pos.z);
        const floatHeight = ground + 6 + Math.sin(time * 2.2) * 0.45;
        player.pos.y += (floatHeight - player.pos.y) * Math.min(1, dt * 4.2);

        cloud.position.copy(player.pos);
        cloud.rotation.y += dt * 0.25;

        // Camera remains centered on the cloud player and follows indefinitely.
        const desiredCamPos = player.pos.clone().add(cameraOffset);
        camera.position.lerp(desiredCamPos, Math.min(1, dt * 3.2));
        camera.lookAt(player.pos.clone().add(cameraLookAhead));

        updateChunks(player.pos.x, player.pos.z);
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      updateChunks(0, 0);
      requestAnimationFrame((t0) => {
        last = t0;
        animate(t0);
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
